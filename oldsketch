let iters = 5;
let visited;
let moveCount = 0;
let forgetThreshold = 16;
let showAllCells = 0;

// convert Hilbert index â†’ (x, y)
function hilbertIndexToXY(n, d) {
  let x = 0;
  let y = 0;

  let t = d;

  for (let s = 1; s < (1 << n); s <<= 1) {
    let rx = 1 & (t >> 1);
    let ry = 1 & (t ^ rx);

    if (ry === 0) {
      if (rx === 1) {
        x = s - 1 - x;
        y = s - 1 - y;
      }

      let temp = x;
      x = y;
      y = temp;
    }

    x += s * rx;
    y += s * ry;

    t >>= 2;
  }

  return [x, y];
}

function generateHilbertOrder(n) {
  let size = 1 << n;
  let total = size * size;

  let points = [];
  for (let i = 0; i < total; i++) {
    points.push(hilbertIndexToXY(n, i));
  }

  return points;
}

function generateMazeWithHilbert(rows, cols) {
  let order = generateHilbertOrder(Math.log2(rows));

  let index = Array(rows)
    .fill()
    .map(() => Array(cols).fill(0));

  for (let i = 0; i < order.length; i++) {
    let [x, y] = order[i];
    index[y][x] = i;
  }

  let maze = Array(rows)
    .fill()
    .map(() =>
      Array(cols)
        .fill()
        .map(() => ({
          north: false,
          south: false,
          east: false,
          west: false
        }))
    );

  for (let k = 0; k < order.length; k++) {
    let [x, y] = order[k];
    let currentIndex = k;

    let neighbors = [];

    const tryNeighbor = (nx, ny, dir) => {
      if (nx < 0 || nx >= cols || ny < 0 || ny >= rows) return;
      if (index[ny][nx] > currentIndex) {
        neighbors.push({ nx, ny, dir });
      }
    };

    tryNeighbor(x + 1, y, "east");
    tryNeighbor(x - 1, y, "west");
    tryNeighbor(x, y + 1, "south");
    tryNeighbor(x, y - 1, "north");

    if (neighbors.length === 0) continue;

    let { nx, ny, dir } = neighbors[floor(random(neighbors.length))];

    if (dir === "east") {
      maze[y][x].east = true;
      maze[ny][nx].west = true;
    } else if (dir === "west") {
      maze[y][x].west = true;
      maze[ny][nx].east = true;
    } else if (dir === "south") {
      maze[y][x].south = true;
      maze[ny][nx].north = true;
    } else if (dir === "north") {
      maze[y][x].north = true;
      maze[ny][nx].south = true;
    }
  }

  return maze;
}


// Entities
class Entity {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  draw(cellSize) {
    let px = this.x * cellSize;
    let py = this.y * cellSize;
    ellipse(px, py, cellSize, cellSize);
  }
}

// Player vision
function computeVisibleCells(px, py, radius) {
  let visible = new Set();
  let queue = [[px, py, 0]];

  while (queue.length > 0) {
    let [x, y, dist] = queue.shift();
    let key = `${x},${y}`;
    if (visible.has(key) || dist > radius) continue;
    visible.add(key);
    visited[y][x] = moveCount; // mark as visited

    let cell = maze[y][x];

    //Add neighbors if there's no wall in that direction
    if (cell.north && y > 0) queue.push([x, y - 1, dist + 1]);
    if (cell.south && y < rows - 1) queue.push([x, y + 1, dist + 1]);
    if (cell.east && x < cols - 1) queue.push([x + 1, y, dist + 1]);
    if (cell.west && x > 0) queue.push([x - 1, y, dist + 1]);
  }

  return visible;
}

// Player
class Player extends Entity {
  constructor(x, y) {
    super(x, y);
  }

  draw(px, py, cellSize) {
    fill(0, 255, 0);
    rect(px + 2, py + 2, cellSize - 4, cellSize - 4);
  }

  move(dx, dy) {
    let nx = this.x + dx;
    let ny = this.y + dy;

    //stay in bounds
    if (nx < 0 || nx >= cols || ny < 0 || ny >= rows) return;

    //reject illegal moves
    let cell = maze[this.y][this.x];
    if (dx === 1 && !cell.east) return;
    if (dx === -1 && !cell.west) return;
    if (dy === 1 && !cell.south) return;
    if (dy === -1 && !cell.north) return;

    // update position
    this.x = nx;
    this.y = ny;

    moveCount ++;
    visited[ny][nx] = moveCount; // mark last visited move
    return true;
  }
}

// Goal
class Goal extends Entity {
  constructor(x, y) {
    super(x, y);
  }

  draw(gx, gy, cellSize) {
    fill(255, 255, 0);
    rect(gx + 2, gy + 2, cellSize - 4, cellSize - 4);
  }
}

// Minotaur
class Minotaur extends Entity {
  constructor(x, y) {
    super(x, y);
    this.dir = 3;
    this.chargeDistance = 3; //0 = N, 1 = E, 2 = S, 3 = W
  }
  
  // check if we can move in our current direction
  canMoveDir(dir, x, y) {
    let cell = maze[y][x];
    if (dir === 0) return cell.north;
    if (dir === 1) return cell.east;
    if (dir === 2) return cell.south;
    if (dir === 3) return cell.west;
  }

  //move 1 cell in our current direction
  step(dir) {
    if (dir === 0) this.y -= 1;
    else if (dir === 1) this.x += 1;
    else if (dir === 2) this.y += 1;
    else if (dir === 3) this.x -= 1;
  }

  //vision: look orthogonally until vision hits walls
  seesPlayerInDirection(dir) {
    let cx = this.x;
    let cy = this.y;

    while (true) {
      //stop if we hit maze boundaries
      if (cx < 0 || cx >= cols || cy < 0 || cy >= rows) break;

      //stop if wall blocks vision
      if (!this.canMoveDir(dir, cx, cy)) break;

      //move one cell
      if (dir === 0) cy -= 1;
      else if (dir === 1) cx += 1;
      else if (dir === 2) cy += 1;
      else if (dir === 3) cx -= 1;

      //check for player
      if (cx === player.x && cy === player.y) return true;
    }

    return false;
  }

  //check vision in all 4 directions
  detectPlayerDirection() {
    for (let d = 0; d < 4; d ++) {
      if (this.seesPlayerInDirection(d)) return d;      
    }
    return null;
  }
  
  update() {
    let spottedDir = this.detectPlayerDirection();

    //charge if player is detected
    if (spottedDir !== null) {
      this.dir = spottedDir; //face player

      for (let i = 0; i < this.chargeDistance; i ++) {
        if (this.canMoveDir(this.dir, this.x, this.y)) {
          this.step(this.dir);

          //stop if player is reached
          if (this.x === player.x && this.y === player.y) break;
        } else {
          break; //stop at wall
        }
      }
      return;
    }

    //normal movement
    let forward = this.dir;
    let left = (this.dir + 3) % 4;
    let right = (this.dir + 1) % 4;
    let backward = (this.dir + 2) % 4;

    let canF = this.canMoveDir(forward, this.x, this.y);
    let canL = this.canMoveDir(left, this.x, this.y);
    let canR = this.canMoveDir(right, this.x, this.y);
    let canB = this.canMoveDir(backward, this.x, this.y);

    //Corridor case: only forward & backward available
    let nonBackwardMoves = [canF, canL, canR].filter(v => v).length;
    if (nonBackwardMoves === 1 && !canL && !canR) {
      //corridor case: forward & backward only
      if (this.seesPlayerInDirection(backward)) {
        this.dir = backward;
        this.step(this.dir);
      } else if (canF) {
        this.dir = forward;
        this.step(this.dir);
      }
      return;
    }

    //Branching paths: choose random non-backward path
    let choices = [];
    if (canF) choices.push(forward);
    if (canL) choices.push(left);
    if (canR) choices.push(right);

    if (choices.length > 0) {
      let chosen = choices[floor(random(choices.length))];
      this.dir = chosen;
      this.step(this.dir);
      return;
    }

    //Fallback: only backward movement is available
    if (canB) {
      this.dir = backward;
      this.step(this.dir);
    }
  }

  draw(mx, my, cellSize) {
    fill(255, 0, 0);
    rect(mx + 2, my + 2, cellSize - 4, cellSize - 4);
  }
}

//start on maze generation
let maze;
let cellSize;
let rows = Math.pow(2, iters);
let cols = Math.pow(2, iters);

let player;
let goal;
let minotaur;

// keyboard commands
function keyReleased() {
  let moved = false;

  if (key === 'w' || keyCode === UP_ARROW) moved = player.move(0, -1);
  else if (key === 's' || keyCode === DOWN_ARROW) moved = player.move(0, 1);
  else if (key === 'a' || keyCode === LEFT_ARROW) moved = player.move(-1, 0);
  else if (key === 'd' || keyCode === RIGHT_ARROW) moved = player.move(1, 0);

  if (moved) {
    minotaur.update();
    redraw();
  }
}

// cell regeneration
function regenerateCellWalls(x, y) {
  let cell = maze[y][x];

  // get neighbors
  let neighbors = [
    {dx: 0, dy: -1, dir: "north", opp: "south"},
    {dx: 1, dy: 0, dir: "east", opp: "west"},
    {dx: 0, dy: 1, dir: "south", opp: "north"},
    {dx: -1, dy: 0, dir: "west", opp: "east"}
  ];

  // Make sure at least one neighbor is connected
  let openDirs = neighbors.filter(n => {
    let nx = x + n.dx;
    let ny = y + n.dy;
    if (nx < 0 || nx >= cols || ny < 0 || ny >= rows) return false;
    return true;
  });

  // Pick at least one open neighbor to keep connectivity
  let guaranteed = openDirs[floor(random(openDirs.length))];

  for (let n of neighbors) {
    let nx = x + n.dx;
    let ny = y + n.dy;
    if (nx < 0 || nx >= cols || ny < 0 || ny >= rows) continue;

    let neighbor = maze[ny][nx];

    //If this is the guaranteed direction, keep it open
    if (n === guaranteed) {
      cell[n.dir] = true;
      neighbor[n.opp] = true;
      continue;
    }

    // Otherwise, randomize it
    let open = random() < 0.5;
    cell[n.dir] = open;
    neighbor[n.opp] = open;
  }
}

function setup() {
  createCanvas(400, 400);
  cellSize = width / (cols);

  //build the maze
  maze = generateMazeWithHilbert(rows, cols);

  noLoop();

  player = new Player(0, 0);
  goal = new Goal(cols - 1, rows - 1);
  minotaur = new Minotaur(cols - 1, 0);

  visited = Array(rows)
    .fill()
    .map(() => Array(cols).fill(-1)); // -1 = never visited
}

function draw() {
  background(0);
  strokeWeight(2);

  // track visible cells
  let visibleCells = computeVisibleCells(player.x, player.y, 3); // radius 3

  for (let y = 0; y < rows; y ++) {
    for (let x = 0; x < cols; x ++) {
      let lastVisited = visited[y][x];

      // determine visibility and memory
      if (visibleCells.has(`${x},${y}`)) {
        fill(255); // fully visible
        stroke(255);

        // regenerate forgotten walls
        if (lastVisited === -1 || moveCount - lastVisited > forgetThreshold) {
          regenerateCellWalls(x, y);
          stroke(255, 0, 0);
        }

        visited[y][x] = moveCount; // update last visited
      } else if (lastVisited !== -1 && moveCount - lastVisited <= forgetThreshold) {
        let fade = 240 - 15 * (moveCount - lastVisited) + 255 * showAllCells;
        fill(fade); // dimmed for memory
        stroke(fade);
      } else {
        fill(255 * showAllCells); // hidden
        stroke(255 * showAllCells);
      }

      let cell = maze[y][x];
      let px = x * cellSize;
      let py = y * cellSize;

      // draw cell background
      rect(px, py, cellSize, cellSize);

      // Draw walls only if visible or visited
      if (visibleCells.has(`${x},${y}`) || lastVisited !== -1) {
        stroke(0);
        strokeWeight(2);
        if (!cell.north) line(px, py, px + cellSize, py);
        if (!cell.south) line(px, py + cellSize, px + cellSize, py + cellSize);
        if (!cell.west) line(px, py, px, py + cellSize);
        if (!cell.east) line(px + cellSize, py, px + cellSize, py + cellSize);
      }
    }
  }

  // draw goal, minotaur and player
  let gx = goal.x * cellSize;
  let gy = goal.y * cellSize;
  goal.draw(gx, gy, cellSize);

  let mx = minotaur.x * cellSize;
  let my = minotaur.y * cellSize;
  minotaur.draw(mx, my, cellSize);

  let px = player.x * cellSize;
  let py = player.y * cellSize;
  player.draw(px, py, cellSize);
}
